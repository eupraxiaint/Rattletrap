using Discord;
using Discord.Commands;
using Discord.WebSocket;
using System;
using System.IO;
using System.Threading.Tasks;
using System.Collections.Generic;
using Microsoft.Extensions.Configuration;
using System.Linq;
using Discord.Rest;
using IronPython.Hosting;
using Microsoft.Scripting;
using Microsoft.Scripting.Hosting;

namespace Rattletrap
{
  public enum PlayerPosition
  {
    Safelane,
    Midlane,
    Offlane,
    SoftSupport,
    Support
  }

  public enum PlayerRank
  {
    Uncalibrated,
    Herald,
    Guardian,
    Crusader,
    Archon,
    Legend,
    Ancient,
    Divine,
    Immortal
  };

  // data struct we use to retrieve data about a particular player - determined via roles
  public class PlayerInfo
  {
    public List<PlayerPosition> Positions = new List<PlayerPosition>();
    public PlayerRank Rank;
    public IGuildUser User;
  }

  public enum MatchState
  {
    Pending,
    WaitingForLobby,
    Canceled
  }

  // manages a single match, generated by queues
  public abstract class IMatch
  {
    // the guild this match was created in
    public GuildInstance GuildInst;

    // the queue this match was created by
    public IQueue SourceQueue;

    // the current state (pending, waiting for lobby, etc) of the match
    public MatchState State;

    // all the players playing in the match
    public List<IGuildUser> Players = new List<IGuildUser>();

    // all players that have readied up
    public List<IGuildUser> ReadyPlayers = new List<IGuildUser>();

    // all players that have declined the match
    public List<IGuildUser> DeclinedPlayers = new List<IGuildUser>();

    // the sequential ID used to identify the match in chat commands
    public int Id;

    // the message sent to announce the match
    public IMessage AnnounceMessage;

    // the time the match was created at
    public DateTime CreatedTime;

    // whether or not the match has been hurried with ;hurryup
    public bool HurryUp;

    // tracks the next match ID to use
    private static int NextMatchId = 0;

    public IMatch(GuildInstance InGuildInst, IQueue InSourceQueue, List<IGuildUser> InPlayers)
    {
      GuildInst = InGuildInst;
      SourceQueue = InSourceQueue;
      State = MatchState.Pending;
      Players = InPlayers;
      Id = NextMatchId++;
      AnnounceMessage = null;
      CreatedTime = DateTime.Now;
      HurryUp = false;
    }

    // called when the match is announced (immediately after being created by a queue)
    public abstract void Announce();

    // called when all players have readied up
    public abstract void OnReady();

    // called when a lobby has been created for the match
    public abstract void OnLobby(String InName, String InPassword);

    // called when the readied players have changed and we need to check if it's been accepted/declined
    public void CheckReady()
    {
      List<IGuildUser> readiedPlayers = new List<IGuildUser>(ReadyPlayers);
      foreach(IGuildUser declinedPlayer in DeclinedPlayers)
      {
        readiedPlayers.Remove(declinedPlayer);
      }

      // if all players are ready, start the match
      if(readiedPlayers.Count == Players.Count)
      {
        OnReady();
        State = MatchState.WaitingForLobby;
        return;
      }

      // if all players have responded but some have canceled, cancel the match
      if(readiedPlayers.Count + DeclinedPlayers.Count == Players.Count)
      {
        String message = $"Match id {Id} declined. Returning to queue: ";
        foreach(IGuildUser user in ReadyPlayers)
        {
          message += user.Mention + " ";
        }

        SourceQueue.AnnouncementChannel.SendMessageAsync(message);

        SourceQueue.Requeue(ReadyPlayers);
        Cancel();
      }
    }

    public void Cancel()
    {
      GuildInst.Matches.Remove(this);
      State = MatchState.Canceled;
    }
  }

  // this is the main service that runs Rattletrap - all commands in MatchModule.cs should be more or less directly
  // making static function calls here
  public class MatchService
  {
    // the discord socket this service uses to communicate with discord
    public static DiscordSocketClient DiscordSocket;

    // the configuration data stored in _config.yml
    private static IConfigurationRoot config;

    // the checkmark emoji
    public static Emoji CheckmarkEmoji = new Emoji("\u2705");

    // the x emoji
    public static Emoji XEmoji = new Emoji("\u274C");

    // the list of positions mapped to emotes
    public static Dictionary<PlayerPosition, string> PositionsToEmotes = new Dictionary<PlayerPosition, string>();

    // the list of guilds mapped to their information structures

    public MatchService(DiscordSocketClient InDiscordSocket, CommandService commands, IConfigurationRoot InConfig)
    {
      DiscordSocket = InDiscordSocket;

      DiscordSocket.GuildAvailable += OnGuildAvailable;

      DiscordSocket.ReactionAdded += OnReactionAdded;
      DiscordSocket.ReactionRemoved += OnReactionRemoved;

      PositionsToEmotes[PlayerPosition.Safelane] = ":one:";
      PositionsToEmotes[PlayerPosition.Midlane] = ":two:";
      PositionsToEmotes[PlayerPosition.Offlane] = ":three:";
      PositionsToEmotes[PlayerPosition.SoftSupport] = ":four:";
      PositionsToEmotes[PlayerPosition.Support] = ":five:";

      config = InConfig;
    }

    // the async task that runs a match once it's created
    // todo: should this maybe be an abstract function on IMatch?
    public static async void RunMatch(IMatch InMatch)
    {
      GuildInstance guildInst = InMatch.GuildInst;

      guildInst.Matches.Add(InMatch);

      // announce the match
      InMatch.Announce();

      // wait here until the readyup timer ends or the match gets hurried
      while((DateTime.Now - InMatch.CreatedTime) < TimeSpan.FromMinutes(5) && !InMatch.HurryUp)
      {
        if(InMatch.ReadyPlayers.Count == InMatch.Players.Count)
        {
          break;
        }
        await Task.Delay(TimeSpan.FromSeconds(5));
      }

      // if everyone readied, the match state should be WaitingForLobby - so cancel the match here if it's not
      if(InMatch.State == MatchState.Pending)
      {
        String message = $"Match id {InMatch.Id} timed out. Returning to queue: ";
        foreach(IGuildUser user in InMatch.ReadyPlayers)
        {
          message += user.Mention + " ";
        }
        InMatch.SourceQueue.AnnouncementChannel.SendMessageAsync(message);

        InMatch.SourceQueue.Requeue(InMatch.ReadyPlayers);
        InMatch.Cancel();
      }
    }

    // runs when a guild is available for the bot. be careful initializing in here, this can get called again if the
    // bot loses internet connection!
    private async Task OnGuildAvailable(SocketGuild InGuild)
    {
      GuildInstance guildInst = GuildInstance.Get(InGuild);

      if(guildInst == null)
      {
        GuildInstance.Create(InGuild);
      }
    }

    // returns whether or not the bot should send messages in the input channel
    public static bool IsAllowedChannel(IGuild InGuild, ITextChannel InChannel)
    {
      GuildInstance guildInst = GuildInstance.Get(InGuild);
      return guildInst.AdminBotChannel == InChannel || guildInst.MainBotChannel == InChannel;
    }

    // adds a user to the matchmaking queue
    public static QueueResult QueueUser(IGuildUser InUser, IQueue InQueue, IGuildUser InTriggeringUser = null, IMessage InTriggeringMessage = null)
    {
      GuildInstance guildInstance = GuildInstance.Get(InUser.Guild);

      foreach(KeyValuePair<string, IQueue> playerCheckQueue in guildInstance.Queues)
      {
        if(playerCheckQueue.Value.IsUserInQueue(InUser))
        {
          return QueueResult.AlreadyQueuing;
        }
      }

      foreach(IMatch match in guildInstance.Matches)
      {
        if(match.State != MatchState.Canceled && match.Players.Contains(InUser))
        {
          return QueueResult.AlreadyInMatch;
        }
      }

      return InQueue.Queue(InUser, InTriggeringUser, InTriggeringMessage);
    }

    // removes a user from the matchmaking queue
    public static UnqueueResult UnqueueUser(IGuildUser InUser, IGuildUser InTriggeringUser = null, IMessage InTriggeringMessage = null)
    {
      GuildInstance guildInst = GuildInstance.Get(InUser.Guild);

      foreach(KeyValuePair<string, IQueue> queue in guildInst.Queues)
      {
        if(queue.Value.IsUserInQueue(InUser))
        {
          queue.Value.Unqueue(InUser, InTriggeringUser, InTriggeringMessage);
          return UnqueueResult.Success;
        }
      }

      return UnqueueResult.NotQueuing;
    }

    // announces a lobby for a match
    public static void AnnounceLobby(IGuild InGuild, IMatch InMatch, string InName, string InPassword)
    {
      GuildInstance guildInst = GuildInstance.Get(InGuild);

      InMatch.OnLobby(InName, InPassword);

      guildInst.Matches.Remove(InMatch);
    }

    // gets the PlayerInfo struct for a user based on their roles
    public static PlayerInfo GetPlayerInfo(IGuild InGuild, IGuildUser InUser)
    {
      GuildInstance guildInst = GuildInstance.Get(InGuild);

      PlayerInfo result = new PlayerInfo();
      result.User = InUser;

      IGuildUser guildUser = InUser as IGuildUser;

      foreach(PlayerPosition position in PlayerPosition.GetValues(typeof(PlayerPosition)))
      {
        if(guildUser.RoleIds.Contains(guildInst.PositionsToRoles[position].Id))
        {
          result.Positions.Add(position);
        }
      }

      if(result.Positions.Count == 0)
      {
        result.Positions.Add(PlayerPosition.Safelane);
        result.Positions.Add(PlayerPosition.Midlane);
        result.Positions.Add(PlayerPosition.Offlane);
        result.Positions.Add(PlayerPosition.SoftSupport);
        result.Positions.Add(PlayerPosition.Support);
      }

      result.Rank = PlayerRank.Uncalibrated;

      foreach(PlayerRank rank in PlayerRank.GetValues(typeof(PlayerRank)))
      {
        IRole role = guildInst.RanksToRoles[rank];
        if(guildUser.RoleIds.Contains(role.Id))
        {
          result.Rank = rank;
          break;
        }
      }

      return result;
    }

    // called when a reaction is added to any message - right now we just use this for readying up
    //
    // todo: break this function up a bit, maybe move some of its implementation to abstract function calls on IMatch
    //       or maybe a separate helper class for readying up?
    private async Task OnReactionAdded(Cacheable<IUserMessage, ulong> cachedMessage, 
      ISocketMessageChannel originChannel, SocketReaction reaction)
    {
      if(reaction.User.Value.Id != DiscordSocket.CurrentUser.Id && reaction.User.IsSpecified && cachedMessage.HasValue)
      {
        SocketGuildChannel channel = originChannel as SocketGuildChannel;

        GuildInstance guildInst = GuildInstance.Get(channel.Guild);

        foreach(IMatch match in guildInst.Matches)
        {
          if(match != null && match.State == MatchState.Pending && match.AnnounceMessage.Id == cachedMessage.Value.Id && match.Players.Contains(reaction.User.Value))
          {
            if(reaction.Emote.Name == CheckmarkEmoji.Name)
            {
              match.ReadyPlayers.Add(reaction.User.Value as IGuildUser);

              match.CheckReady();
            }
            else if(reaction.Emote.Name == XEmoji.Name)
            {
              match.DeclinedPlayers.Add(reaction.User.Value as IGuildUser);

              match.CheckReady();
            }

            break;
          }
        }
      }
    }

    // called when a reaction is removed from any message - right now we just use this for readying up
    private async Task OnReactionRemoved(Cacheable<IUserMessage, ulong> cachedMessage, 
      ISocketMessageChannel originChannel, SocketReaction reaction)
    {
      if(reaction.User.Value.Id != DiscordSocket.CurrentUser.Id)
      {
        SocketGuildChannel channel = originChannel as SocketGuildChannel;

        GuildInstance guildInst = GuildInstance.Get(channel.Guild);

        foreach(IMatch match in guildInst.Matches)
        {
          if(match.AnnounceMessage.Id == cachedMessage.Value.Id && match.State == MatchState.Pending && 
            match.Players.Contains(reaction.User.Value))
          {
            if(reaction.Emote.Name == CheckmarkEmoji.Name)
            {
              match.ReadyPlayers.Remove(reaction.User.Value as IGuildUser);
              match.CheckReady();
            }
            else if(reaction.Emote.Name == XEmoji.Name)
            {
              match.DeclinedPlayers.Remove(reaction.User.Value as IGuildUser);
              match.CheckReady();
            }

            break;
          }
        }
      }
    }

    public enum HurryUpResult
    {
      Success,
      MatchNotPending
    }

    // hurries up a match, causing its ready-up timer to expire
    public static HurryUpResult HurryUp(IMatch InMatch)
    {
      if(InMatch.State != MatchState.Pending)
      {
        return HurryUpResult.MatchNotPending;
      }

      InMatch.HurryUp = true;

      return HurryUpResult.Success;
    }
  } 
}